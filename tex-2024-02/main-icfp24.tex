\documentclass[acmsmall,anonymous,review,screen]{acmart}
\pdfoutput=1
\usepackage{agda}
\usepackage{stmaryrd}
\usepackage{listings}

% Turn off ligatures ending in "-".
% Without this Agda Comments "--" are typeset as "–".
\usepackage[T1]{fontenc}
\usepackage{microtype}
\DisableLigatures[-]{encoding=T1}

%% There is a limit of 25 pages for a full paper or Functional Pearl
%% and 12 pages for an Experience Report; in either case, the
%% bibliography and an optional clearly marked appendix will not be
%% counted against these limits. Submissions that exceed the page
%% limits or, for other reasons, do not meet the requirements for
%% formatting, will be summarily rejected. 


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\input{unicodeletters}
\input{agdamacros}

%% listings
\lstset{
  language=haskell,
  basicstyle=\ttfamily,
  morekeywords={send,recv,close,send_on_,receive,End,Int,Chan},
  captionpos=b,
  literate=
  {-o}{${\multimap}$}1
  {ex}{$\exists$}1
  {all}{$\forall$}1
  {\\x}{$\times$}1
  %{(x)}{$\otimes$}1
  {fresh}{$\lozenge$}1
  {~~}{$\approx$}1
}


\usepackage{agda-generated}


\newenvironment{AgdaBlock}{%
  \vspace{\AgdaEmptySkip}%
  \AgdaNoSpaceAroundCode{}%
}{%
  \AgdaSpaceAroundCode{}
  % \vspace{\AgdaEmptySkip}
}


\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Intrinsic Types, a Logical Relation, and the Scourge of the Transfer Lemma}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%% Author with single affiliation.
\author{Hannes Saffrich}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0009-0004-7014-754X}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  % \department{Department1}              %% \department is recommended
  \institution{University of Freiburg}            %% \institution is required
  %\streetaddress{Street1 Address1}
  %\city{City1}
  % \state{State1}
  % \postcode{Post-Code1}
  \country{Germany}                    %% \country is recommended
}
\email{saffrich@informatik.uni-freiburg.de}          %% \email is recommended


\author{Peter Thiemann}
% \authornote{Both authors contributed equally to this research.}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

\author{Marius Weidner}
% \authornotemark[1]
\email{weidner@cs.uni-freiburg.de}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
We explore the definition of an intrinsically typed interpreter for
stratified System F in Agda.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Agda, stratified System F, extensionality}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{sec:introduction}

Defining semantics is one of the key activities of a programming
languages researcher. We learn that there are different styles of
dynamics (small-step, big-step, denotational, just to name the most
frequently used one), each with different trade-offs. When it comes to
implementing or mechanizing semantics, there are further options to
choose from, in particular if we are also interested in statics.

One important choice is whether we want to express the statics
extrinsically or intrinsically, that is, do we want to start with
untyped syntax and then define the statics as an afterthought, or do
we integrate types with the syntax.

If we opt for intrinsically typed syntax, some properties are already paid
for by construction. For instance, a small-step semantics for intrinsically typed
syntax satisfies type preservation by construction. For another
instance, consider specifying a denotational semantics by a
compositional mapping from syntax to some semantic domain. With 
untyped syntax, the semantic domain has to lump the interpretations of
different types together and distinguish them using type tags. But with intrinsically
typed syntax the semantics can map into type-indexed semantic domains
and thus elide type tags. This observation directly translates to tagless interpreters
on intrinsically typed syntax, which elide tag checks at run time.

For concreteness, we show the well-known example of a tagless
interpreter for the simply-typed lambda calculus implemented in Agda in
Figure~\ref{fig:stlc}. We define the syntax as an inductive data type along with
a compositional mapping to the semantic domain, spanned by Agda's
natural number type and the function space. 
We define intrinsically typed syntax of expressions as an inductive datatype
parameterized over a typing environment and indexed on the return
type. For variables, we use de Bruijn indices into the typing
environment.
\begin{figure}[tp]
  \input{latex/STLC}
  \caption{Simply typed lambda calculus, denotationally}
  \label{fig:stlc}
\end{figure}

The semantics of a typing environment is a run-time environment in the
form of a heterogenous list of suitably typed values. With all that,
we can define the semantics of an expression {\AESem} as a function from
the semantics of a typing environment {\AGSem} to the semantics of the type
{\ATSem}. Clearly this definition also serves as a tagless interpreter for
the simply-typed lambda calculus, which means that type preservation
is also built into its definition. Moreover, as Agda accepts this
definition as terminating, we know that evaluation of every
simply-typed lambda term terminates; a non-trivial semantic property
of the simply-typed lambda calculus.

Agda-encodings of intrinsically-typed interpreters have been explored
quite a lot, but rarely in the context of polymorphic source
languages. One possible reason is that the archetypical polymorphic
lambda calculus, System~F, cannot be embedded in Agda because of its
impredicativity. This begs the question if we can develop a tagless
interpreter for a predicative version of System~F in Agda.

We answer this question affirmatively for Leivant's stratified version
of the polymorphic lambda calculus \cite{DBLP:journals/iandc/Leivant91}. The key idea of his
calculus is to stratify the set of polymorphic types in levels such
that universal quantification only ranges over strictly smaller
levels. This restriction literally embodies predicativity and, as we
will discover, the stratification corresponds directly to Agda's
universe stratification.


% As the construction is more involved than the one for simply-typed
% lambda calculus, we only give the key definitions and discuss some of
% the problems arising on the way to tagless interpretation. 

% \input{latex/Tagless-final}
\section{Types}
\label{sec:types}

The definition of the type language for stratified System~F is taken literally from Leivant's
paper. It is defined as an inductive type parameterized over a level
environment (that assigns levels to free type variables) and indexed
over the level of the type. 
\TFType
The number type is just a set and inhabits level $0$.
The level of a function type $S \Rightarrow T$ is the maximum of the
levels of $S$ and $T$.
Type variables live at their declared level.
The level of a universal quantification at
level $l$ is the maximum of $l + 1$ and the level of the body.

As for the simply-typed lambda calculus, we can define a compositional
mapping from type syntax to Agda types.
\TFTSem
Given a type at level $l$, this function returns an Agda type in
$\ASet~l$. To do so it needs a domain environment  {\ADEnv} to interpret type
variables. This environment gets accessed by function {\Alookup} and
it gets extended in the last clause that maps
universal quantification to a dependent function that takes an element
of $\ASet~l$ and pushes it on the environment.

The type of the domain environment is interesting because its range type is
unusual.
\TFTEnv
The environment contains the interpretations of the type
variables. These values can live in some $\ASet~l$, for any finite
level $l$, which means we cannot assign the type {\ADEnv} any finite
level. Hence, the type {\ADEnv} lives in the limit type $\ASeto$, as
shown in this definition. 

\section{Expressions}
\label{sec:expressions}

Inspired by the encoding of System $F\omega$ by Chapman and coworkers
\cite{DBLP:conf/mpc/ChapmanKNW19}, we define a 
unified context for type variables and term variables. Contexts grow to the left.
\TFTVEnv
Membership of a term variable in a context is defined by the
{\Ainn} relation.
\TFinn
The constructors {\Ahere} and {\Athere} locate or skip over variable bindings.
The last alternative {\Atskip} skips over a type binding. Hence, the type
$T$ we find outside the binding must be weakened to account for the
extra type variables (using {\ATwk}). Weakening is a special case of renaming, which
is implemented as advocated by Benton and coworkers \cite{DBLP:journals/jar/BentonHKM12}.

The type of expressions is now given as follows.
\TFExpr
We add numeric values and the successor function as examples of observables.
Variables, lambda abstractions, and application are encoded just like
for the simply-typed lambda calculus.
Type abstraction \texttt{\ACon{Λ} $l$ \ACon{⇒} $e$} takes a level $l$ and a body where the new type
variable is bound to $l$. 
Type application \texttt{$e$ \ACon{∙} $T'$} takes an expression with universal quantification at
level $l$ and a type $T'$ of level $l$. It constructs an expression
where type $T'$ has been substituted in the body $T$ of the
quantified type.

\section{Substitutions}
\label{sec:substitutions}

In this work, as in \citet{DBLP:journals/jar/BentonHKM12} and
\citet{DBLP:conf/mpc/ChapmanKNW19}, substitutions arise on two levels:
on types and on expressions. Type substitutions hold no surprises as
they are just like substitutions for the simply-typed lambda calculus (see
\cite{DBLP:journals/scp/KokkeSW20}), but expression substitutions are
more complicated as they are indexed by type substitutions.

\subsection{Type Substitutions}
\label{sec:substitutions:type}

The infrastructure for substitutions on types is standard for
intrinsically-typed terms in de Bruijn
style, and defines substitutions in terms of renamings
(cf.~\cite{DBLP:journals/jar/BentonHKM12, DBLP:conf/mpc/ChapmanKNW19, DBLP:journals/scp/KokkeSW20}).

% \begin{figure}[tp]
%   \caption{Simply typed lambda calculus, denotationally}
%   \label{fig:stlc}
% \end{figure}

% \noindent\hspace{-\fboxsep}
% \begin{minipage}{0.5\linewidth}
%   \SubDefTRen
%   \SubDefTren
%   \SubDefTliftR
%   \SubDefTidR
% \end{minipage}
% \begin{minipage}{0.5\linewidth}
%   \SubDefTSub
%   \SubDefTsub
%   \SubDefTliftS
%   \SubDefTidS
% \end{minipage}

Renamings {\ATRen} and substitutions {\ATSub} are defined as
functions mapping type variables to type variables and types, respectively.

\noindent\hspace{-\fboxsep}
\begin{minipage}{0.5\linewidth}
  \SubDefTRen
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \SubDefTSub
\end{minipage}

The operations for applying renamings and substitutions, {\ATren}
and {\ATsub}, are defined by induction over the type. When the
operations need to go under a binder, they lift the renaming and
substitution with {\ATliftR} and {\ATliftS}, respectively.

\noindent\hspace{-\fboxsep}
\begin{minipage}{0.5\linewidth}
  \SubDefTren
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \SubDefTsub
\end{minipage}

The identity renaming {\ATidR} and substitution
{\ATidS} behave like the identity function and the variable
type constructor, respectively, and act as neutral elements when applied to a type:

\noindent\hspace{-\fboxsep}
\begin{minipage}{0.5\linewidth}
  \begin{AgdaBlock}
    \SubDefTidR
    \TFTidRNeutral
  \end{AgdaBlock}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{AgdaBlock}
    \SubDefTidS
    \TFTidSNeutral
  \end{AgdaBlock}
\end{minipage}



To prove lemmas about the interaction of multiple renamings and substitutions,
compositions and fusion lemmas are defined for all four combinations
of renamings and substutions.
For example, the composition of two type substitutions is defined by
\SubstExamplesTCompSS
% \SubDefTCompositionSS
with the corresponding fusion lemma:
\SubstExamplesFusionTSubTSub
% \TFFusionSubSub

With the help of the fusion lemmas, we prove interaction lemmas
between renamings and substitutions, e.g., that any substitution
\ACode{σ} can be swapped with a weakening \AFun{Twk} by lifting \ACode{σ}:
\TFSwapTsubTwk

% or that any substitution \ACode{σ} can be swapped with a singleton substitution by lifting σ:
% \TFSwapTsubSingle

% \SubDefTCompositionRR
% \SubDefTCompositionRS
% \SubDefTCompositionSR
% \TFFusionRenRen
% \TFFusionRenSub
% \TFFusionSubRen

\subsection{Expression Substitutions}
\label{sec:substitutions:expr}

The infrastructure for expression substitution is conceptionally very similar to
that of type substitution.
The main difference is that expression substitutions are indexed by
type substitutions (cf.~\cite{DBLP:conf/mpc/ChapmanKNW19}).
This approach reduces redundancy by defining a combined type-in-expression and
expression-in-expression substitution operation.
We only present the definitions for substitutions, because
the definitions for renamings are analogous.

For any type substitution \ACode{σ*}, an expression substitution of
type \ACode{\AESub~σ*~Γ₁~Γ₂} is a function that maps variables of type \ACode{T} in
\ACode{Γ₁} to expressions of type \ACode{\ATsub~σ*~T} in \ACode{Γ₂}.
\SubDefESub

The operation {\AEsub} of applying an expression substitution \ACode{σ} to an expression,
performs an expression-in-expression substitution according to \ACode{σ},
and a type-in-expression substitution according to its index \ACode{σ*}.
The operation is defined by induction on the expression, and lifts \ACode{σ} when
going under an expression- or type-binder using {\AEliftS} and
{\AEliftSL}, respectively.
\SubDefEsub

% When formalizing type soundness of System F wrt. a small-step
% semantics, no fusion lemmas are needed for expression substitution.
% This is different in our formalization, because we need to prove interactions
% between syntactic and semantic substitutions, which require ...

% While defining composition and proving fusion lemmas for expression substitution
% works essentially the same as for type-substitution, technical problems
% arise due to the use of the \Asubst-lemma. We defer the discussion of
% those problems to Section~\ref{sec:subst-hell}, but the symptoms
% become already visible here.

% Consider for example the composition of two expression substitutions:

The composition of two expression substitutions \ACode{σ₁} and \ACode{σ₂}, which
are indexed with type substitutions \ACode{σ₁*} and
\ACode{σ₂*}, respectively, yields an expression substitution that
is indexed with the composition of the type substitutions,
\ACode{σ₁* ∘Tₛₛ σ₂*}.
\SubstExamplesECompSS
% \SubDefECompositionSS

In contrast to the composition of type substitutions, the term
\ACode{\AEsub~\_~σ₁~(σ₂~\_~\_~x)} cannot be returned directly,
as it has type \ACode{\AExpr~Δ₃~Γ₃~(\ATsub~σ₁*~(\ATsub~σ₂*~T))},
while a term of the propositionally equivalent type
\ACode{\AExpr~Δ₃~Γ₃~(\ATsub~(σ₁* ∘Tₛₛ σ₂*)~T)} is expected.
The required type conversion is achieved by applying the
{\Asubst}-lemma with the appropriate fusion lemma for type
substitutions as a witness. 
The {\Asubst}-lemma is defined in Agda's standard library as
followed:
\SubstExamplesDef

The same type conversion is also necessary in the corresponding fusion lemma:
\SubstExamplesFusionESubESub

The proofs for the expression substitution lemmas are entirely standard with the
exception that the use of {\Asubst} introduces annoying technical problems.
We defer the discussion of these problems to Section~\ref{sec:subst-hell}.
% \EFFusionSubSub

% \SubDefERen
% \SubDefEren
% \SubDefECompositionRR
% \SubDefECompositionRS
% \SubDefECompositionSR
% \EFFusionRenRen
% \EFFusionRenSub
% \EFFusionSubRen

\section{Semantics}
\label{sec:semantics}

\subsection{Denotational}
\label{sec:denotational}



It remains to define a compositional function from the expression
syntax to the semantic domain that we already prepared in
Section~\ref{sec:types}. We start with value environments.
\TFVEnv
Value environments are represented as functions---we could have done
that in the simply-typed interpreter, too. They are indexed by a
domain environment $\eta$ to be able to calculate the correct return type.

The definition of the interpretation function follows.
\TFExprSem
The cases for numerical constants and the successor function are straightforward.
The cases for term variables, lambda abstraction, and application are
similar to the  simply-typed lambda calculus.

The first issue arises in the case for type abstraction. We interpret
a type abstraction at level $l$ as a function with argument type
$\ASet~l$. This argument has to be pushed onto the domain environment
$\eta$ and we have to account at the value level for the additional
type variable in the context. The following function
adapts the types.
\TFExtendTskip
Semantically, all we need is $(\gamma\ \_\ \_\ x)$, but it does not have
the expected type. The {\Asubst} function enables us to apply a lemma
to the type. It establishes that interpreting a
weakened type in an extended domain environment gives the same result
as interpreting the type in the orginal domain environment.
The actual statement of this lemma is for arbitrary
renamings. This added generality is needed to prove it.
\TFRenPreservesSemanticsType
The argument $Tren^*$ roughly states that $\eta_1$ and $\eta_2$ are domain
environments related by renaming $\rho^*$ by precomposition  $\eta_1 \equiv \eta_2 \circ \rho^*$.
The proof of the lemma is by induction on $T$ with an interesting
subgoal in the case for universal quantification:
%\TFProblematicGoal
We can show that the ranges of the function are equal
with the inductive hypothesis, but the standard extensionality principle does
not let us expose this equation. However, standard extensionality can be used to prove a
dependent extensionality principle (from the standard library), which enables us to complete the proof.
\TFDependentExt

The final case for type application opens two different cans of
worms. First, the type of the right hand side does not match the
expected type. Essentially, we have to prove that the composition of
the meaning function for types commutes with substitution. Here
$T[T']$ substitutes $T'$ for the outermost variable of $T$.
\TFSingleSubstPreserves
Second, some steps in the proof involve equalities over entities of
$\ASeto$. These cannot be handled with the standard definition of
propositional equality which works parametrically for entities of
$\ASet~l$, for any $l$, but not for $\ASeto$. While it is easy to
define an equality type at $\ASeto$, it is somewhat tedious to
re-establish the standard toolbox for transforming equality proofs
like {\Acong}, {\Asubst}, {\Atrans}, and equational reasoning to deal with $\ASeto$.

\subsection{Big Step Operational}
\label{sec:big-step-operational}

A standard big-step operational semantics serves as the second
reference point for the logical relation. We discuss it here because
it contains a design choice that is crucial for proving the
fundamental theorem in Section~\ref{sec:fundamental}.

We start by defining the
standard notions of closed expressions {\ACExpr} and values {\AValue}, the latter being
pairs of a closed expression and evidence {\AisValue} that it is a syntactic value.
\BigStepCExpr
\BigStepisValue
\BigStepValue
The evaluation judgment relates closed expressions to closed values.
Its inference rules define a standard call-by-value evaluation.
For simplicity we treat the ``big lambda'' as a syntactic value
without asking its body to be a value, too.\footnote{This choice works out for the
  side-effect-free language that we consider here. If the language had
  effects, we would enforce the well-known value restriction by
  requiring the body of the big lambda to be a syntactic value.}
\BigStepSemantics

The reader may wonder why the evaluation relation does not simply relate two closed
expressions. While this approach works almost all the way, we
failed to prove the (expression) variable case of the fundamental theorem with
it. The problem is that the variable case does not constrain the type
of the variable's value, so that we cannot recover its shape via
the {\AisValue} type. In particular, the type of an expression variable can be
a type variable, so that the type is unknown at compile time. See Section~\ref{sec:fundamental}.

With our present setup we can prove that any syntactic value evaluates to itself.
\BigStepValueReduceSelf

\subsection{Soundness}
\label{sec:soundness}

At this point, we can prove the soundness of the operational semantics
with respect to the denotational semantics. As the denotational
semantics directly assigns the final meaning to an expression,
evaluation does not matter in that it returns a value with the same
meaning.
\BigStepSoundnessType
The proof of this theorem is remarkably simple, mostly by appealing to the
inductive hypotheses. The cases for function application and type
application require two lemmas {\AEEsingleSubstPreserves} and
{\AETsingleSubstPreserves} that relate semantic substitution with
expression-in-expression substitution and type-in-expression
substitution, respectively.
\ESPSEEsingleSubstPreserves
\ESPSETsingleSubstPreserves
These lemmas have similar problems with equalities as the fusion
lemmas for expression substitution (cf.\
Section~\ref{sec:substitutions:expr}), which are 
addressed using the methods outlined in
Section~\ref{sec:subst-hell}. However, there is an additional
complication that some of the equalities relate elements of $\ASeto$,
which again leads to replication of infrastructure.

\section{Logical Relation}
\label{sec:logical-relation}


We define a binary logical relation for finitely stratified System F.
Its definition largely follows the development of the logical relation
for System F in Ahmed's lecture notes \cite{DBLP:journals/corr/abs-1907-11133,ahmed23:_oplss}.
We first define the relation for closed values and expressions and
then lift it open expressions.

We are going slowly and detailed to highlight the places where
nontrivial steps are needed to mechanize the results. Our relation is
not the ``standard'' binary logical relation that relates two
expressions with the goal of proving contextual equivalence or
parametricity under a small-step operational semantics. We rather
follow \citet{DBLP:journals/jar/BentonHKM12} and relate an expression
under big-step semantics to its denotational semantics.

\subsection{Relating closed values}
\label{sec:relat-clos-valu}

Generally, we talk about type-indexed relations {\AREL} between syntactic values of type $T$ to semantic values of the same
type. This relation also depends on the stratification level.
\LogicalREL
A relation environment $\rho : \ADSemx{\ensuremath{\Delta}}$ abstracts over the
current instantiation of the type variables. It maps a type variable to a
type paired with its relational interpretation.  It is needed to
define the cases for type abstraction and type application in a
compositional, terminating way.
\LogicalRelEnv
Clearly, the first ``half'' of a relation environment is a type
substitution and we use lifted projection functions $\pi_1$ and
$\pi_2$ to obtain this substitution and the actual relation.

We define the extension of a relation environment by a new a new type
variable binding analogous to the extension
of a substitution. This extension is needed in the case for universal
quantification.
\LogicalREext

On the semantics side it remains to define the action of a type
substitution on a semantic environment $\eta$. It returns a new
semantic environment that interprets each substituted type according
to $\eta$.
\TFsubstToEnv

With these definitions in place, we can state the type of the logical relation.
\LogicalMCVType
The  relation {\AVSem} on values is defined by induction on the type $T$ and the parameter
$\rho$ contains the relation environment. The intention is to define a
relation on objects of type $T$ after closing $T$ with the relation
environment. Hence, we apply $\rho$'s type substitution to the type of
the syntactic value and interpret $T$ in the environment created from
the relation environment.
The value relation is mutually recursive with the expression relation
{\AESem}, which interposes evaluation.
\LogicalMCVBody
The definition itself is an extension of the logical relation for the
simply-typed lambda calculus by
\citet{DBLP:journals/jar/BentonHKM12}. It is straightforward
except for the type adjustments using the {\Asubst} function. We
discuss those type adjustments after explaining the relations.

At the number type, values are constants equal to their semantic
interpretation. 
 At function type $T_1 \Rightarrow T_2$ we relate a lambda expression
to a semantic function $f$ in
the usual way: given arguments $w$ and $z$ related at type $T_1$, we ask that the
application of the lambda to $w$ evaluates to a syntactic value $v$ that is
related to $(f z)$ at type $T_2$.
We interpret a type variable by looking it up in the relation
environment.
At universal type $\forall l, T$ we relate a big lambda to a semantic
function $F$ as follows: given any type argument $T'$ and relation $R :
\AREL\ T'$, evaluating the type application to a syntactic value $v$,
we find that this $v$ is related at type $T$ to the
function $F$ applied to the semantics of $T'$, but in an extended
relation environment that binds the type variable to $(T', R)$.

The expression relation extends the value relation by interposing
evaluation on the syntactic side. The denotation $z$ remains the
same, which is the essence of denotational semantics. 
\LogicalMCE

The definitions of {\AVSem} and {\AESem} are terminating because their
recursive invocations strictly refer to subterms of the argument type.

The occurrence of {\Asubst} in two places indicates that the expected types do not quite
match the demanded types.
The case for type variables has to cater for the action of the
substitution $\pi_1\rho$ on the semantics. The semantics of type $T$
is parameterized over the interpretation of its free type
variables. Hence, we have to show that the semantics of the type is
preserved by this substituion.
\TFsubstVarPreservesType
The case for type application has to cater for an equality between
type substitutions that boils down to a standard lemma on composing
substitutions.
\LogicallemmaOne

The reader may wonder if these two type mismatches are an
artifact of our definition. For example, we might have chosen a
different type for the value relation:
\LogicalVariationMCVType
Alas, this choice gets rid of the {\Asubst} in the case for type
variables, but an additional {\Asubst} is needed in the case for type
application. We show the relevant part of the definition, but will not go further into this matter.
\LogicalVariationMCVBodyUniversal

We close with a usability aspect.
In the definition of {\AVSem} it is crucial that we only pattern match
against the type and enforce the structure of values by equations on
the right hand side of the definitions. This choice ensures that {\AVSem}
reduces as soon as the type is sufficiently known.

\subsection{Semantic soundness}
\label{sec:relat-open-expr}

To lift the expression relation {\AESem} to open expressions we start
with an expression of type \texttt{$e$ : Expr Δ Γ T} and want to relate it
to its denotational interpretation \AESemx{\ensuremath{e}}. As the type $T$
may also contain type variables, we first need a relational
environment $\rho$ and its semantic counterpart $\eta$ to interpret
the type variables as suitable sets.
Next, we need a closing substitution $\chi$ that maps the free
variables of $e$ to closed values while taking into account the
instantiation of the type variables. On the denotational side, we need
a corresponding semantic environment \texttt{γ : Env Δ Γ η} that maps
free variables of $e$ to their denotations. Finally, the closing
substitution and the semantic environment need to send variables to
items related by {\AVSem}. To this end, we extend {\AVSem} to a
relation {\AGSem} on environments.

Taken together, these assumptions enable the definition of semantic soundness.
\FundamentalSemanticSoundness

Let's dissect the parts. First, the closing value substitution:
\LogicalCSub
This type is pretty much the same as the type for an expression
substitution with two differences. First, it is indexed by a closing
type substitution $\sigma^*$ and, second, it returns a closed value instead of an
expression. The latter is needed to prove the variable case of the
fundamental lemma. There is a projection function to obtain the
underlying expression substitution analogous to $\pi_1$.
\LogicalESSC

The relation {\AGSem} extends {\AVSem} to relate closing substitutions
with semantic environments. The {\AlevelEnv} function (omitted) calculates the universe level
of the resulting conjunction from the levels of the types in the
context.
\LogicalMCG
The empty environments are related in the empty context.
If the context starts with a variable binding, then the head entries of
the environments are related by {\AVSem} and their tails are
related by {\AGSem}.
The various \texttt{drop} functions pop the head entry from the
respective environments.
If the context starts with a type variable binding, then this binding
does not contribute to the relation, but we still have to skip over it
by popping the head entry of the relation environment and adjusting the
substitution and the semantic environment.
The respective \texttt{drop} and \texttt{drop-t} functions may be
found in the supplemental material.

\subsection{Fundamental theorem}
\label{sec:fundamental}

The fundamental theorem of the logical relation tells us that we can
prove semantic soundness for a well-typed expression.
\FundamentalFundamentalType

This proof is very easy for constants and for the successor.
\FundamentalFundamentalConstant
The three components of the resulting value of type {\AESem} contain
\begin{enumerate}
\item the result is a syntactic value for the number $n$,
\item evidence that this value reduces to itself, and
\item the value relation: the denotational semantics yields the same
  number $n$ with the two {\Arefl}s fixing the equality between the
  syntactic value and the semantics. 
\end{enumerate}
\FundamentalFundamentalSuccessor
Here we just lift the relation that we obtain as an induction
hypothesis for $e$ to the successor.
\FundamentalFundamentalVariable
The case for variables relies on the machinery we built up so
far. We obtain the syntactic value of the variable from the
substitution $\chi$. Then we obtain the value relation for this value
from {\AGSem} and construct the result from $w$, the proof that $w$
evaluates to itself, and the value relation. We have to rely on
{\AValueDown} for the proof because there is no way to infer the shape
of $w$ from $T$ (which might be a type variable, for instance).
We will have a closer look at some technicalities involving
{\AGLookup} in Section~\ref{sec:technical-lemmas}  

\FundamentalFundamentalLambda
The intuition of the case for lambda abstraction is
well-known. Roughly, we
have to show that for all values $w$ and $z$, which are related at
type $T_1$, the result of function application is related at type
$T_2$. To this end, we invoke the fundamental theorem at type $T_2$
with suitably extended context, closing substitution, semantic
environment, and relational environment. The latter requires some
lemmas as shown in $eq_1$ and $eq\omega_1$: if we extend an
environment by one entry and then drop that entry, the resulting
environment is extensionally equal to the initial one. The lemma
$eq\omega_1$ requires equality at $\ASeto$, so a custom version
{\Asubstlo} of the {\Asubst} function is needed: it applies two
equalities, one at a finite level, the other at level $\omega$. The
fundamental theorem gives the correct result, only its type needs to be adjusted
using a standard equation $eq_2$ about substitutions.

\FundamentalFundamentalApplication
The case for function application is proved by invoking the respective
inductive hypotheses and exploiting the definition of the value
relation for functions.


We defer the remaining cases to the supplemental material.
The case for type abstraction is similar, but slightly more involved than the case
for lambda abstraction.
The case for type application constitutes an outright annoying
excursion to ``subst hell'', where an overwhelming number of type
mismatches needs to be addressed in the proof. Section~\ref{sec:subst-hell} explains
ways of handling these problems.

\subsection{Adequacy}
\label{sec:adequacy}

The adequacy theorem constitutes the holy grail of any development
using logical relations.
Suppose we have a closed expression $e$ of number type.
If the denotational semantics of $e$ is the number $n$, then the big-step
semantics applied to $e$ terminates and yields the syntactic value for
$n$.
To state adequacy we first have to construct an empty
environment of type \texttt{Env [] {\Anull} []}.

\begin{minipage}{0.3\linewidth}
  \FundamentalEmptyEnv
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \FundamentalEmptyRelEnv
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \FundamentalEmptyCSub
\end{minipage}
\FundamentalAdequacyType
This theorem follows immediately from the semantic soundness that we proved with the
fundamental theorem.
\FundamentalAdequacyBody
We just invoke the fundamental theorem with empty context and empty
environments and analyze the result. The auxiliary lemma
{\ACsubClosed} proves that applying the empty substitution acts like
the identity substitution on a closed expression.
\FundamentalCsubClosed


\subsection{Technical lemmas}
\label{sec:technical-lemmas}

The variable case of the fundamental theorem relies on the function
{\AGLookup} to obtain the value relation for the variable from the
value relation for the context. 
\LRVrenMCGLookupType

Its definition starts innocently:
\LRVrenMCGLookupBody

{\dots} but the type of the inductive hypothesis \textit{ih} is
significantly different from the expected type.
The following lemma describes this discrepancy: The value relation for
the weakened type $T$ in the relation environment $\rho$ is the same
as the value relation for $T$ in the relation environment $\rho$ after
dropping the head entry. We will not delve into the technical
explanation of the required equalities on type substitutions and
semantics functions.
\LRVrenLRVwk
To add insult to the injury, this lemma cannot be proved directly, but
it rather has to be generalized to arbitrary renamings acting on the
type.
We can finally prove this renaming lemma with another excursion to
``subst hell''.
\LRVrenLRVrenEqType

The proof of the renaming lemma is the one place where we refer to the
lemma {\AFusionESubESub} for expression substitutions.

There is also a version {\ALRVsub} of the above lemma where a type substitution
(instead of a type renaming) acts on a logical relation. This
adaptation is needed to prove the case for type application of the
fundamental lemma.

\section{A Journey to Subst-Hell}
\label{sec:subst-hell}

The largest difficulty in the formalization is caused by an unfortunate
technical nuisance involving the {\Asubst}-lemma from Agda's standard library:

\SubstExamplesDef

The {\Asubst}-lemma enables us to use a value of a type at a different,
but propositionally equivalent, type.
This lemma becomes relevant when an equality proof cannot be matched
on, because it witnesses the equality between two non-unifiable
expressions, e.g. between two function applications: \texttt{f x $\equiv$ g y}.

It is harmless to use {\Asubst} in a proof, but if a {\Asubst} appears
in the \emph{type} of a proof, then often complications arise.
In this section, we take a closer look at these complications and
discuss two approaches to combat them. We do so by looking at two
alternative proofs of the fusion lemma for expression substitutions from
Section~\ref{sec:substitutions:expr}.

\subsection{Homogeneous Equality}
\label{sec:subst-hell:hom}

The following shows our first version of the type application case
{\ACon{\_∙\_}} of the fusion lemma:

\begin{AgdaBlock}
  \SubstExamplesFusionESubESub
  \SubstExamplesFusionESubESubBody
\end{AgdaBlock}

This proof contains eight different uses of the {\Asubst} lemma!
To increase readability, we replaced each {\Asubst} 
with an auxilliary definition {\AFun{Sᵢ} = \Asubst~\AFun{Fᵢ}~\AFun{Eᵢ}}.
As the concrete arguments {\AFun{Fᵢ}} and {\AFun{Eᵢ}} are not relevant to the
discussion, we elided the \AKw{where}-block containing their
definitions from the presentation. The non-trivial proof terms {\AFun{pᵢ}} are explained below.

In line \ACom{(1)}, the {\AFun{S₁}} comes from the lemma statement itself.
In line \ACom{(2)}, the inner {\AEsub} from line \ACom{(1)} has been reduced, which
introduced another {\Asubst} we call {\AFun{S₂}}.
The {\AFun{S₂}} blocks the reduction of the outer {\AEsub}.
It is impossible to get {\AFun{S₂}} to reduce, because {\AFun{E₂}} is
an equality proof between two function applications, so it cannot be
matched on.
Instead, we pull the {\AFun{S₂}} outwards, which transforms it into
{\AFun{S₃}} as shown in line \ACom{(3)}. This allows the outer {\AEsub}
to reduce, leading to another {\Asubst} we call {\AFun{S₄}} in line \ACom{(4)}.

Pulling {\AFun{S₂}} outwards is possible because {\AEsub} is sufficiently polymorphic:
it is well-typed when called both with and without {\AFun{S₂}} -- it just produces values
of different but propositionally equivalent types, which needs to be accounted for with {\AFun{S₃}}.
The trick for proving this equation, consists in abstraction:
if we can generalize the equation, such that all equality proofs occuring in {\AFun{S₂}}
and  {\AFun{S₃}} witness equalities between variables, e.g. \ACode{x~\AFun{≡}~y}, then
we can simply match on the equality proofs and the {\AFun{Sᵢ}} reduce away.
This is exactly what our {\AFun{dist-subst}} lemma does:
\SubstExamplesDistSubst
To prove the equation required to go from line \ACom{(2)} to \ACom{(3)}, we
instantiate {\AFun{dist-subst}} as follows:
\SubstExamplesFusionESubESubBodyProofA

% We then continue the proof from the other side: in line \ACom{(6)},
% we reduced the {\AEsub} from line \ACom{(7)}, which introduced {\AFun{S₅}}.
% To go from line \ACom{(6)} to line \ACom{(5)}, we applied the
% induction hypothesis to the left side of the type application and the
% type fusion lemma {\AFun{fusion-Tsub-Tsub}} to the right side.
% On first look, it seems that this is a case for the {\AFun{cong₂}} lemma,
% which states that if \AgdaCode{a₁ \AFun{≡} a₂} and \AgdaCode{b₁ \AFun{≡} b₂}
% then \AgdaCode{f a₁ b₁ \AFun{≡} f a₂ b₂}. Unfortunately, type application {\ACon{\_∙\_}} is
% not a valid choice for \AgdaCode{f}, because the second argument of type application, i.e. the \ACode{t}
% in \AgdaCode{e \ACon{∙} t}, appears in the index of the type of \AgdaCode{e \ACon{∙} t}.

% \SubstExamplesFusionESubESubBodyProofB

The rest of the proof requires two more lemmas related to {\Asubst}:
\begin{enumerate}
\item the equation for {\AFun{p₂}} between line \ACom{(4)} and \ACom{(5)} states that if
  different {\Asubst}s are applied to the same term, then the terms are still equal.
  This is intuitively true, because {\Asubst} behaves like the identity function
  after it matched on the equality proof;
\item the equation for {\AFun{p₃}} between line \ACom{(5)} and \ACom{(6)} requires another
  use of {\AFun{dist-subst}} to pull {\AFun{S₆}} out of the left
  argument of the type application, which introduces {\AFun{S₈}};
\item the equation for {\AFun{p₄}} between line \ACom{(6)} and \ACom{(7)} is where
  the actual meat of the proof is. Here the induction hypothesis is applied to the
  left side of the type application and the fusion lemma for type substitutions
  is applied to the right side of the type application. However, changing
  the right side of the type application, changes the type of the
  whole type application, so another {\Asubst} lemma is required, which exchanges
  the right side of the type application and inserts another {\Asubst}
  {\AFun{S₈}} around it:
  \begin{AgdaBlock}
    \SubstExamplesCongTApp
    \SubstExamplesFusionESubESubBodyProofD
  \end{AgdaBlock}
\end{enumerate}

This is a lot of technical proof work for equations that are obviously
true, because {\Asubst} is semantically just an identity function!
Let us take a step back to describe a different solution.

% The rest of the proof uses similar techniques, so we take a step back
% to describe a different solution.

% Instead of taking a closer look at the proofs

\subsection{Heterogeneous Equality}
\label{sec:subst-hell:het}

Heterogeneous equality was introduced by
\cite{DBLP:conf/types/McBride00} as \emph{John Major equality} and
is defined in Agda as follows:
\SubstExamplesHetEqDef
In contrast to homogeneous equality \AFun{\_≡\_}, heterogenous
equality expresses equalities between values of different
types. It is particularly useful to state and prove equalities between
values of different but propositionally equal types.

Before we revisit the proof example from the previous subsection, we take a look
at three lemmas from Agda's standard library about heterogeneous equality:

\begin{enumerate}
\item 
  Applications of the {\Asubst} lemma can be simply removed with heterogeneous equality:
  \SubstExamplesHetEqSubstRemovable
\item 
  The {\AFun{cong₂}} lemma for heterogeneous equality lifts
  equalities for the arguments of a binary function to an equality 
  for the function result.
  \SubstExamplesHetEqCongII
\item 
  A homogeneous equality can be converted to a heterogeneous equality:
  \SubstExamplesHetEqConv
\end{enumerate}

Equipped with these lemmas, we turn back to our proof example:
\SubstExamplesFusionESubESubHet
Now that we can equate terms of different types, the lemma can be
stated without using {\Asubst}.
Consequently, the {\AFun{S₁}} in line \ACom{(1)} disappears.
However, in lines \ACom{(2)}, \ACom{(4)}, and \ACom{(7)}, we still get
{\AFun{S₂}} ({\AFun{S₄}}, {\AFun{S₅}}, respectively) from reducing the application of {\AESub}.
We cannot avoid {\AFun{S₂}} as {\AESub} is a definition, which has to
produce a term of exactly the type it is checked against.
In lines \ACom{(4)} and \ACom{(7)}, we can use the {\AFun{≡-subst-removable}} lemma
directly to remove {\AFun{S₄}} and {\AFun{S₅}}, respectively:
\SubstExamplesFusionESubESubHetProofB

In line \ACom{(2)}, the application of {\AFun{S₂}} does no occur on the outside but as an argument to
\ACode{\AFun{Esub}~σ₁*~σ}. One might expect that a unary {\AFun{cong}} lemma can be used to
lift the {\AFun{≡-subst-removable~F₂~E₂}~\_} equality under the application.
Alas, a unary {\AFun{cong}} can only replace values of the \emph{same} type.
To be able to call a function like {\AFun{Esub}} with arguments of two different types,
those types need to be instances of the same type family \ACode{B},
i.e., the function needs to have a type of the shape
\ACode{\{x~:~A\}~→~(y~:~B~x)~→~C~x~y}, and we actually want to
replace an argument of type \ACode{B~a} with one of type \ACode{B~b}.
In this example, \ACode{\AFun{Esub}~σ₁*~σ} has type
\ACode{\{T~:~\AFun{Type}~Δ₂~l\}~→~(e~:~\AFun{Expr}~Δ₂~Γ₂~T)~→~\AFun{Expr}~Δ₃~Γ₃~(\AFun{Tsub}~σ₁*~T)}.
This can be expressed with {\AFun{cong₂}} as followed:
\SubstExamplesFusionESubESubHetProofA

In line \ACom{(5)} we have a similar situation where we want to use the
induction hypothesis on the left side of the type application and the
fusion lemma for type substitutions on the right side.  Instead of a
binary {\AFun{cong₂}}, we need a ternary {\AFun{cong₃}} to account
for the type-index of the expression:
\SubstExamplesFusionESubESubHetProofC

\subsection{Assessment}
\label{sec:assessment}
We found that heterogeneous equality significantly simplifies the complications arising from
using {\Asubst} in definitions and lemma statements. While it completely removes the need for
{\Asubst} in the statements of equational lemmas, some {\Asubst}
applications still show up in equality proofs due to the unfolding of definitions, where {\Asubst}
cannot be avoided in an intrinsically typed setting.
These {\Asubst} applications have to be removed manually, which with heterogeneous
equality behaves much more regular than with homogeneous equality. In
fact, we started our formalization with homogenous equality,
which required us to prove around 20 lemmas in the style of
\AFun{dist-subst}. Switching to heterogeneous equality enabled us to
replace all of them with a combination of just two ingredients: the {\AFun{≡-subst-removable}}
lemma and {\AFun{cong}} lemmas of different arities.

% Consider for example the type \texttt{Vec} -- a list that
% intrinsically tracks its length -- and its append function \verb/_++_/:
% \SubstExamplesVec
% \SubstExamplesAppend

% Stating that \verb/_++_/ is associative requires us to use a {\Asubst}:
% \SubstExamplesAssocType
% The term \texttt{(xs ++ ys) ++ zs} has type \texttt{Vec A ((m + n) + p)}, whereas
% the term \texttt{xs ++ (ys ++ zs)} has type \texttt{Vec A (m + (n + p))}, so a
% {\Asubst} is needed to apply the associativity of addition.

% \SubstExamplesAppendR

% % \SubstExamplesAssoc
% \SubstExamplesAssocR

% % \SubstExamplesAssocHet
% \SubstExamplesAssocRHet

% \SubstExamplesDistSubst
% \SubstExamplesSubstRemovable




% It is harmless to use {\Asubst} in proofs, but if it is used in
% regular definitions, then complications arise in subsequent
% equational lemmas about those definitions, where the {\Asubst}
% reappears.

% Old Example %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % Consider for example the definition of the substitution type:
% % \SubstExamplesESubDef

% Consider for example the definition of the identity expression-substitution:
% \SubstExamplesEidDef

% One would expect \texttt{Eid} to simply map each variable \texttt{x}
% to its corresponding variable term \texttt{\AgdaInductiveConstructor{`} x}.
% However, because the type of expression substitutions \texttt{ESub} is
% indexed by a type-substitution -- in this case \texttt{Tid} -- we need
% to produce a value of type \texttt{Expr Δ Γ (Tsub Tid T)}, while
% the variable term \texttt{\AgdaInductiveConstructor{`} x} has type \texttt{Expr Δ Γ T}.
% The two types are obviously equivalent, but only propositionally due
% to the lemma \texttt{TidT≡T : ∀ T → Tsub Tidₛ T ≡ T}, so a
% {\Asubst} is needed to adjust the type.\footnote{
%   Similar problems also appear if separate definitions for
%   expression-in-expression and type-in-expression substitutions are
%   employed instead of indexing expression-substitutions with type-substitutions.
% }

% This {\Asubst} now reappears in lemmas about \texttt{Eid}, e.g. when proving
% that \texttt{Eid} is the neutral element for expression-substitution \texttt{Esub}:
% \SubstExamplesEidNeutral

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Excursion: Small-Step Operational Semantics}
\label{sec:excurs-small-step}

A small-step operational semantics completes our picture of finitely
stratified System~F. Here, we demonstrate that we can wrap the small-step semantics such that the definition of the logical relation as well as the proof of the fundamental theorem adapt without any effort.

We define an intrinsically-typed small-step reduction relation and its
reflexive transitive closure in the usual way (details omitted).
\SmallStepSingleReduction
\SmallStepReduction

The same lemmas as for the big-step semantics serve to prove the
soundness of small-step reduction:
A small-step reduction step does not change the denotational semantics.
\SmallStepSoundness

The interesting part is the following definition of a ``big-step API'' for the small-step semantics.
First we define an evaluation judgment based on the small-step semantics.
\SmallStepBigAPI
Then we define functions analogous to the constructors of the big-step semantics as well as the function stating that values do not reduce.
\SmallStepBigAPIFunctions
We omit their definitions, which amount to the proof that the small-step semantics simulates the big-step semantics.

While the definition of the logical relation and some of the proofs leading up to adequacy make use of the API, but for the big-step evaluation relation, none of them performs pattern matching against its constructors. Hence, replacing them by the API functions for the small-step semantics does not affect any of the proofs.
In consequence, the identical definitions yield a logical relation for
the small-step semantics with all proofs in place.


\section{Related Work}
\label{sec:related-work}

Arjen Rouvoet's thesis~\cite{DBLP:phd/basesearch/Rouvoet21} gives an
excellent overview of the state of the art in intrinsically typed
techniques for modeling language semantics. He pushed the limits of
this technology in a range of papers with various coauthors
\cite{DBLP:journals/pacmpl/RestPRVM22,DBLP:journals/pacmpl/RouvoetKV21,DBLP:conf/cpp/RouvoetPKV20,DBLP:journals/pacmpl/PoulsenRTKV18}. 

Giving semantics in an interpretive style is a defining feature of
denotational semantics \cite{Schmidt1986}, but it can be traced back
to Reynolds's idea of definitional interpreters \cite{Reynolds1975}.

The particular encoding of de Bruijn style variable representations
used in this work dates back to work on nested datatypes
\cite{DBLP:conf/mpc/BirdM98,DBLP:journals/jfp/BirdP99,DBLP:conf/csl/AltenkirchR99},
which subsequently lead to GADTs
\cite{cheney03:_first_class_phant_types}.

A tagless interpreter for a simply typed calculus was developed in
Cayenne \cite{augustsson99}, but for extrinsically typed syntax (i.e.,
syntax and separate typing predicatepe).

Intrinsically typed encodings are further studied by Allais and others
\cite{DBLP:conf/cpp/Allais0MM17}, who define a range of tagless
functions including denotational semantics on intrinsically typed
terms. 

We draw some inspiration from the program implemented by Benton and coworkers
\cite{DBLP:journals/jar/BentonHKM12}. Based on intrinsically typed
syntax for a simply-typed lambda applied calculus, they define a
big-step semantics and a set-theoretic denotational semantics. They
prove soundness of the former semantics with respect to the latter as
well as adequacy (using a logical relation). They also develop an
intrinsically typed expression encoding for System~F and discuss the
definitions of renaming and substitution for types and expressions.
While their expression encoding is slightly different (their
expression context does not contain type variable bindings), they run
into very similar problems with equalities on type substitutions than
our work. While they propose to lift all reasoning to heterogeneous
equality, we additionally propose a direct approach to deal with
equalities. 
The paper stops short of discussing the denotational/operational
semantics of System~F nor does it define a logical relation for it.

Chapman and coworkers \cite{DBLP:conf/mpc/ChapmanKNW19} formalized
System F$\omega$ in Agda using intrinsically typed encodings for types
and terms. Our encodings for types, terms, and substitutions are
simplified versions of their definitions, while their work is
significantly complicated by the need to normalize types. While they
prove similar results about type substitutions than we do, they do not
prove the fusion lemmas for expression substitutions (see
Section~\ref{sec:substitutions:expr}). The latter fusion lemmas are needed to
prove the fundamental theorem (see
Section~\ref{sec:technical-lemmas}), but they are not required for
their executable formalization of System~F$\omega$.

The POPLMark reloaded project \cite{DBLP:journals/jfp/AbelAHPMSS19} proposes
mechanized proofs of strong normalization for a simply typed lambda
calculus using logical relations as a challeging testbed for proof
assistants. Their pen-and-paper blueprint for the proof relies on
intrinsically typed syntax using a calculus with explicit
substitutions and full normalization. They highlight challenging
problems that come up during formalization or proof and outline
solutions in several different systems. 

The logical approach to type soundness
\cite{timany24:_logic_approac_type_sound} advertises the use of Iris
as a domain specific language to define logical relations. Iris
\cite{DBLP:journals/jfp/JungKJBBD18} is much more than that, it is a
framework for higher-order concurrent separation logic that is
implemented as a domain specific language in Coq.
Iris enables the definition of step-indexed Kripke logical relations (SKLR),
which go way beyond the facilities we demonstrate in this paper.
To do so, it relies on a custom program logic created to express SKLRs
\cite{DBLP:journals/corr/abs-1103-0510}. 
We see the value of our contribution in several aspects.
\begin{enumerate}
\item Iris relies on Coq, which supports an impredicative type
  theory, whereas Agda's underlying theory is predicative. In Iris we
  can formalize full System~F, but our
  formalization of finitely stratified System~F explores the limit of
  meaningful reasoning about polymorphic languages in plain Agda.
  (Agda would choke on the specification of the value relation at type
  $\forall\alpha.T$ for full System~F.)
\item An exploration of the limits of intrinsically typed syntax, in
  particular with respect to dealing with nontrivial type equalities
  caused by its use.
\end{enumerate}

\section{Conclusion}
\label{sec:conclusion}
\label{sec:future-work}

The ``POPLMark reloaded'' paper \cite[Section 5.1]{DBLP:journals/jfp/AbelAHPMSS19}
says in its critical summary:
\begin{quotation}
  We feel that the jury is still out regarding the intrinsic versus
  extrinsic types encoding debate: on one hand, the intrinsic type
  discipline when it works---and recent results
  \cite{DBLP:journals/pacmpl/PoulsenRTKV18} shows that it applies
  outside the usual suspects---yields very compact and economic
  encodings. On the other, extrinsic typing scales more easily to
  dependent types
  \cite{DBLP:conf/types/Danielsson06,DBLP:journals/entcs/Chapman09,DBLP:conf/popl/AltenkirchK16}
  and see, for example, the Agda formalization in \citet{DBLP:journals/pacmpl/0001OV18}. 
\end{quotation}
It is our impression that the present work demonstrates the limits of
the intrisically-typed approach. For System~F, the development up to a
type soundness proof is tedious, but workable. However, once we
consider applications that require non-trivial results about
expression substitutions, transfer lemmas abound and clutter proofs
significantly. We believe that these issues are not an artifact of the
particular design choices we made in defining the syntax, as
\citet{DBLP:journals/jar/BentonHKM12} chose another reasonable syntax
design and ran into the same problems with equalities.


A few extensions seem within reach. It should be possible to extend
our approach to System F$\omega$ as formalized by
\citet{DBLP:conf/mpc/ChapmanKNW19}. The logical relation as such would
not be affected, but the supporting lemmas would have to be adjusted
to cater for normalization etc.

It would also be interesting to extend the stratified calculus by
level quantification as in Agda's universe polymorphism. However, Agda
assigns universe polymorpic functions the type $\ASeto$. In
consequence,  this extension no longer has a seamless denotational
embedding in Agda as the meaning of a term lives either in $\ASet\
\ell$  or in $\ASeto$. A suitable result type to hold either value is
defineable, but it lives in $\ASeto_1$. Thus, reasoning about it
requires further variants of equality types beyond $\ASeto$. Moreover, the definition of
the denotational semantics is no longer as clean as shown in
Section~\ref{sec:denotational}. 


%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
% \begin{acks}
% To Robert, for the bagels and explaining CMYK and color spaces.
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}


%%
%% If your work has an appendix, this is the place to put it.
% \appendix


\end{document}
\endinput
%%
%% End of file `sample-acmsmall-submission.tex'.
