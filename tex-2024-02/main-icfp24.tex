\documentclass[acmsmall,anonymous,review,screen]{acmart}
\pdfoutput=1
\usepackage{agda}
\usepackage{stmaryrd}
\usepackage{listings}

%% There is a limit of 25 pages for a full paper or Functional Pearl
%% and 12 pages for an Experience Report; in either case, the
%% bibliography and an optional clearly marked appendix will not be
%% counted against these limits. Submissions that exceed the page
%% limits or, for other reasons, do not meet the requirements for
%% formatting, will be summarily rejected. 


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\input{unicodeletters}
\input{agdamacros}

%% listings
\lstset{
  language=haskell,
  basicstyle=\ttfamily,
  morekeywords={send,recv,close,send_on_,receive,End,Int,Chan},
  captionpos=b,
  literate=
  {-o}{${\multimap}$}1
  {ex}{$\exists$}1
  {all}{$\forall$}1
  {\\x}{$\times$}1
  %{(x)}{$\otimes$}1
  {fresh}{$\lozenge$}1
  {~~}{$\approx$}1
}


\usepackage{agda-generated}


\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Intrinsic Types, a Logical Relation, and the Scourge of the Transfer Lemma}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%% Author with single affiliation.
\author{Hannes Saffrich}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0009-0004-7014-754X}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  % \department{Department1}              %% \department is recommended
  \institution{University of Freiburg}            %% \institution is required
  %\streetaddress{Street1 Address1}
  %\city{City1}
  % \state{State1}
  % \postcode{Post-Code1}
  \country{Germany}                    %% \country is recommended
}
\email{saffrich@informatik.uni-freiburg.de}          %% \email is recommended


\author{Peter Thiemann}
% \authornote{Both authors contributed equally to this research.}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

\author{Marius Weidner}
% \authornotemark[1]
\email{weidner@cs.uni-freiburg.de}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
We explore the definition of an intrinsically typed interpreter for
stratified System F in Agda.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Agda, stratified System F, extensionality}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{sec:introduction}

Defining semantics is one of the key activities of a programming
languages researcher. We learn that there are different styles of
dynamics (small-step, big-step, denotational, just to name the most
frequently used one), each with different trade-offs. When it comes to
implementing or mechanizing semantics, there are further options to
choose from, in particular if we are also interested in statics.

One important choice is whether we want to express the statics
extrinsically or intrinsically, that is, do we want to start with
untyped syntax and then define the statics as an afterthought, or do
we integrate types with the syntax.

If we opt for intrinsically typed syntax, some properties are already paid
for by construction. For instance, a small-step semantics for intrinsically typed
syntax satisfies type preservation by construction. For another
instance, consider specifying a denotational semantics by a
compositional mapping from syntax to some semantic domain. With 
untyped syntax, the semantic domain has to lump the interpretations of
different types together and distinguish them using type tags. But with intrinsically
typed syntax the semantics can map into type-indexed semantic domains
and thus elide type tags. This observation directly translates to tagless interpreters
on intrinsically typed syntax, which elide tag checks at run time.

For concreteness, we show the well-known example of a tagless
interpreter for the simply-typed lambda calculus implemented in Agda in
Figure~\ref{fig:stlc}. We define the syntax as an inductive data type along with
a compositional mapping to the semantic domain, spanned by Agda's
natural number type and the function space. 
We define intrinsically typed syntax of expressions as an inductive datatype
parameterized over a typing environment and indexed on the return
type. For variables, we use de Bruijn indices into the typing
environment.
\begin{figure}[tp]
  \input{latex/STLC}
  \caption{Simply typed lambda calculus, denotationally}
  \label{fig:stlc}
\end{figure}

The semantics of a typing environment is a run-time environment in the
form of a heterogenous list of suitably typed values. With all that,
we can define the semantics of an expression {\AESem} as a function from
the semantics of a typing environment {\AGSem} to the semantics of the type
{\ATSem}. Clearly this definition also serves as a tagless interpreter for
the simply-typed lambda calculus, which means that type preservation
is also built into its definition. Moreover, as Agda accepts this
definition as terminating, we know that evaluation of every
simply-typed lambda term terminates; a non-trivial semantic property
of the simply-typed lambda calculus.

Agda-encodings of intrinsically-typed interpreters have been explored
quite a lot, but rarely in the context of polymorphic source
languages. One possible reason is that the archetypical polymorphic
lambda calculus, System~F, cannot be embedded in Agda because of its
impredicativity. This begs the question if we can develop a tagless
interpreter for a predicative version of System~F in Agda.

We answer this question affirmatively for Leivant's stratified version
of the polymorphic lambda calculus \cite{DBLP:journals/iandc/Leivant91}. The key idea of his
calculus is to stratify the set of polymorphic types in levels such
that universal quantification only ranges over strictly smaller
levels. This restriction literally embodies predicativity and, as we
will discover, the stratification corresponds directly to Agda's
universe stratification.


% As the construction is more involved than the one for simply-typed
% lambda calculus, we only give the key definitions and discuss some of
% the problems arising on the way to tagless interpretation. 

% \input{latex/Tagless-final}
\section{Types}
\label{sec:types}

The definition of the type language for stratified System~F is taken literally from Leivant's
paper. It is defined as an inductive type parameterized over a level
environment (that assigns levels to free type variables) and indexed
over the level of the type. 
\TFType
The number type is just a set and inhabits level $0$.
The level of a function type $S \Rightarrow T$ is the maximum of the
levels of $S$ and $T$.
Type variables live at their declared level.
The level of a universal quantification at
level $l$ is the maximum of $l + 1$ and the level of the body.

As for the simply-typed lambda calculus, we can define a compositional
mapping from type syntax to Agda types.
\TFTSem
Given a type at level $l$, this function returns an Agda type in
$\ASet~l$. To do so it needs a domain environment  {\ADEnv} to interpret type
variables. This environment gets accessed by function {\Alookup} and
it gets extended in the last clause that maps
universal quantification to a dependent function that takes an element
of $\ASet~l$ and pushes it on the environment.

The type of the domain environment is interesting because its range type is
unusual.
\TFTEnv
The environment contains the interpretations of the type
variables. These values can live in some $\ASet~l$, for any finite
level $l$, which means we cannot assign the type {\ADEnv} any finite
level. Hence, the type {\ADEnv} lives in the limit type $\ASeto$, as
shown in this definition. 

\section{Expressions}
\label{sec:expressions}

Inspired by the encoding of System $F\omega$ by Chapman and coworkers
\cite{DBLP:conf/mpc/ChapmanKNW19}, we define a 
unified context for type variables and term variables. Contexts grow to the left.
\TFTVEnv
Membership of a term variable in a context is defined by the
{\Ainn} relation.
\TFinn
The constructors {\Ahere} and {\Athere} locate or skip over variable bindings.
The last alternative {\Atskip} skips over a type binding. Hence, the type
$T$ we find outside the binding must be weakened to account for the
extra type variables (using {\ATwk}). Weakening is a special case of renaming, which
is implemented as advocated by Benton and coworkers \cite{DBLP:journals/jar/BentonHKM12}.

The type of expressions is now given as follows.
\TFExpr
We add numeric values and the successor function as examples of observables.
Variables, lambda abstractions, and application are encoded just like
for the simply-typed lambda calculus.
Type abstraction \texttt{Λ $l$ ⇒ $e$} takes a level $l$ and a body where the new type
variable is bound to $l$. 
Type application \texttt{$e$ ∙ $T'$} takes an expression with universal quantification at
level $l$ and a type $T'$ of level $l$. It constructs an expression
where type $T'$ has been substituted in the body $T$ of the
quantified type.

\section{Substitutions}
\label{sec:substitutions}

\subsection{Type Substitutions}
\label{sec:substitutions:type}

The infrastructure for type-substitutions is standard for
intrinsically-typed terms in de Bruijn
style, and defines substitutions in terms of renamings as in
\cite{DBLP:journals/jar/BentonHKM12, DBLP:journals/scp/KokkeSW20}.

% \begin{figure}[tp]
%   \caption{Simply typed lambda calculus, denotationally}
%   \label{fig:stlc}
% \end{figure}

% \noindent\hspace{-\fboxsep}
% \begin{minipage}{0.5\linewidth}
%   \SubDefTRen
%   \SubDefTren
%   \SubDefTliftR
%   \SubDefTidR
% \end{minipage}
% \begin{minipage}{0.5\linewidth}
%   \SubDefTSub
%   \SubDefTsub
%   \SubDefTliftS
%   \SubDefTidS
% \end{minipage}

Renamings {\ATRen} and substitutions {\ATSub} are defined as
functions mapping variables to variables and types, respectively.

\noindent\hspace{-\fboxsep}
\begin{minipage}{0.5\linewidth}
  \SubDefTRen
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \SubDefTSub
\end{minipage}

The operations for applying renamings and substitutions, {\ATren}
and {\ATsub}, are defined by induction over the type. When the
operations need to go under a binder, they lift the renaming and
substitution with {\ATliftR} and {\ATliftS}, respectively.

\noindent\hspace{-\fboxsep}
\begin{minipage}{0.5\linewidth}
  \SubDefTren
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \SubDefTsub
\end{minipage}

The identity renaming {\ATidR} and substitution
{\ATidS} behave like the identity function and the variable
type constructor, respectively, and act as neutral elements when applied to a type:

\noindent\hspace{-\fboxsep}
\begin{minipage}{0.5\linewidth}
  \SubDefTidR
  \TFTidRNeutral
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \SubDefTidS
  \TFTidSNeutral
\end{minipage}


To prove lemmas about the interaction of multiple renamings and substitutions,
compositions and fusion lemmas are defined for all four combinations
of renamings and substiutions.
For example, the composition of two type substitutions is defined by
\SubstExamplesTCompSS
% \SubDefTCompositionSS
with the corresponding fusion lemma:
\SubstExamplesFusionTSubTSub
% \TFFusionSubSub

TODO: Show some of the interaction lemmas, e.g. that weakening cancels singleton-substitution?

% \SubDefTCompositionRR
% \SubDefTCompositionRS
% \SubDefTCompositionSR
% \TFFusionRenRen
% \TFFusionRenSub
% \TFFusionSubRen

\subsection{Expression Substitutions}
\label{sec:substitutions:expr}

The infrastructure for expression substitution is conceptionally very similar to
that of type substitution.
The main difference is that expression substitutions are indexed by
type substitutions (cf.~\cite{DBLP:conf/mpc/ChapmanKNW19}).
This allows to reduce redundancy by defining a combined type-in-expression and
expression-in-expression substitution operation.
We only present the definitions for substitutions, because
the definitions for renamings are analogous.

For any type substitution \AgdaCode{σ*}, an expression substitution of
type \AgdaCode{\AESub~σ*~Γ₁~Γ₂} maps variables of type \AgdaCode{T} in
\AgdaCode{Γ₁} to expressions of type \AgdaCode{\ATsub~σ*~T} in \AgdaCode{Γ₂}.
\SubDefESub

The operation {\AEsub} of applying an expression substitution \AgdaCode{σ} to an expression,
performs an expression-in-expression substitution according to \AgdaCode{σ},
and a type-in-expression substitution according to its index \AgdaCode{σ*}.
The operation is defined by induction on the expression, and lifts \AgdaCode{σ} when
going under an expression- or type-binder using {\AEliftS} and
{\AEliftSL}, respectively.
\SubDefEsub

% When formalizing type soundness of System F wrt. a small-step
% semantics, no fusion lemmas are needed for expression substitution.
% This is different in our formalization, because we need to prove interactions
% between syntactic and semantic substitutions, which require ...

% While defining composition and proving fusion lemmas for expression substitution
% works essentially the same as for type-substitution, technical problems
% arise due to the use of the \Asubst-lemma. We defer the discussion of
% those problems to Section~\ref{sec:subst-hell}, but the symptoms
% become already visible here.

% Consider for example the composition of two expression substitutions:

The composition of two expression substitutions \AgdaCode{σ₁} and \AgdaCode{σ₂}, which
are indexed with type substitutions \AgdaCode{σ₁*} and
\AgdaCode{σ₂*}, respectively, yields an expression substitution that
is indexed with the composition of the type substitutions,
\AgdaCode{σ₁* ∘Tₛₛ σ₂*}.
\SubstExamplesECompSS
% \SubDefECompositionSS

In contrast to the composition of type substitutions, the term
\AgdaCode{\AEsub~\_~σ₁~(σ₂~\_~\_~x)} cannot be returned directly,
as it has type \AgdaCode{\AExpr~Δ₃~Γ₃~(\ATsub~σ₁*~(\ATsub~σ₂*~T))},
while a term of the propositionally equivalent type
\AgdaCode{\AExpr~Δ₃~Γ₃~(\ATsub~(σ₁* ∘Tₛₛ σ₂*)~T)} is expected.
The required type conversion is achieved with the {\Asubst}-lemma
using the fusion lemma for type substitutions as a witness.

The same type-conversion is also necessary in the corresponding fusion lemma:
\SubstExamplesFusionESubESub

The proofs for the expression substitution lemmas are entirely standard with the
exception that the use of {\Asubst} introduces annoying technical problems.
We defer the discussion of these problems to Section~\ref{sec:subst-hell}.
% \EFFusionSubSub

% \SubDefERen
% \SubDefEren
% \SubDefECompositionRR
% \SubDefECompositionRS
% \SubDefECompositionSR
% \EFFusionRenRen
% \EFFusionRenSub
% \EFFusionSubRen

\section{Semantics}
\label{sec:semantics}

\subsection{Denotational}
\label{sec:denotational}



It remains to define a compositional function from the expression
syntax to the semantic domain that we already prepared in
Section~\ref{sec:types}. We start with value environments.
\TFVEnv
Value environments are represented as functions---we could have done
that in the simply-typed interpreter, too. They are indexed by a
domain environment $\eta$ to be able to calculate the correct return type.

The definition of the interpretation function follows.
\TFExprSem
The cases for numerical constants and the successor function are straightforward.
The cases for term variables, lambda abstraction, and application are
similar to the  simply-typed lambda calculus.

The first issue arises in the case for type abstraction. We interpret
a type abstraction at level $l$ as a function with argument type
$\ASet~l$. This argument has to be pushed onto the domain environment
$\eta$ and we have to account at the value level for the additional
type variable in the context. The following function
adapts the types.
\TFExtendTskip
Semantically, all we need is $(\gamma\ \_\ \_\ x)$, but it does not have
the expected type. The {\Asubst} function enables us to apply a lemma
to the type. It establishes that interpreting a
weakened type in an extended domain environment gives the same result
as interpreting the type in the orginal domain environment.
The actual statement of this lemma is for arbitrary
renamings. This added generality is needed to prove it.
\TFRenPreservesSemanticsType
The argument $Tren^*$ roughly states that $\eta_1$ and $\eta_2$ are domain
environments related by renaming $\rho^*$ by precomposition  $\eta_1 \equiv \eta_2 \circ \rho^*$.
The proof of the lemma is by induction on $T$ with an interesting
subgoal in the case for universal quantification:
%\TFProblematicGoal
We can show that the ranges of the function are equal
with the inductive hypothesis, but the standard extensionality principle does
not let us expose this equation. However, standard extensionality can be used to prove a
dependent extensionality principle (from the standard library), which enables us to complete the proof.
\TFDependentExt

The final case for type application opens two different cans of
worms. First, the type of the right hand side does not match the
expected type. Essentially, we have to prove that the composition of
the meaning function for types commutes with substitution. Here
$T[T']$ substitutes $T'$ for the outermost variable of $T$.
\TFSingleSubstPreserves
Second, some steps in the proof involve equalities over entities of
$\ASeto$. These cannot be handled with the standard definition of
propositional equality which works parametrically for entities of
$\ASet~l$, for any $l$, but not for $\ASeto$. While it is easy to
define an equality type at $\ASeto$, it is somewhat tedious to
re-establish the standard toolbox for transforming equality proofs
like {\Acong}, {\Asubst}, {\Atrans}, and equational reasoning to deal with $\ASeto$.

\subsection{Big Step Operational}
\label{sec:big-step-operational}

A standard big-step operational semantics serves as the second
reference point for the logical relation. We discuss it here because
it contains a design choice that is crucial for proving the
fundamental theorem in Section~\ref{sec:fundamental}.

We start by defining the
standard notions of closed expressions {\ACExpr} and values {\AValue}, the latter being
pairs of a closed expression and evidence {\AisValue} that it is a syntactic value.
\BigStepCExpr
\BigStepisValue
\BigStepValue
The evaluation judgment relates closed expressions to closed values.
Its inference rules define a standard call-by-value evaluation.
For simplicity we treat the ``big lambda'' as a syntactic value
without asking its body to be a value, too.\footnote{This choice works out for the
  side-effect-free language that we consider here. If the language had
  effects, we would enforce the well-known value restriction by
  requiring the body of the big lambda to be a syntactic value.}
\BigStepSemantics

The reader may wonder why the evaluation relation does not simply relate two closed
expressions. While this approach works almost all the way, we
failed to prove the (expression) variable case of the fundamental theorem with
it. The problem is that the variable case does not constrain the type
of the variable's value, so that we cannot recover its shape via
the {\AisValue} type. In particular, the type of an expression variable can be
a type variable, so that the type is unknown at compile time. See Section~\ref{sec:fundamental}.

However, with our present setup we can use the following lemma to show
that a syntactic value evaluates to itself.
\BigStepValueReduceSelf

\section{Logical Relation}
\label{sec:logical-relation}


We define a binary logical relation for finitely stratified System F.
Its definition largely follows the development of the logical relation
for System F in Ahmed's thesis/lecture notes \cite{AhmedLR}.
We first define the relation for closed values and expressions and
then lift it open expressions.

We are going slowly and detailed to highlight the places where
nontrivial steps are needed to mechanize the results.

\subsection{Relating closed values}
\label{sec:relat-clos-valu}

Generally, we talk about type-indexed relations {\AREL} between syntactic values of type $T$ to semantic values of the same
type. This relation also depends on the stratification level.
\LogicalREL
A relation environment {\ARelEnv} abstracts over the current instantiation of the
type variables. It maps a type variable to a
type paired with its relational interpretation.  It is needed to
define the cases for type abstraction and type application in a
compositional, terminating way.
\LogicalRelEnv
Clearly, the first ``half'' of a relation environment is a type
substitution and we use lifted projection functions $\pi_1$ and $\pi_2$ to obtain this
substitution and the actual relation.

We define the extension of a relation environment by a new a new type
variable binding analogous to the extension
of a substitution. This extension is needed in the case for universal
quantification.
\LogicalREext

On the semantics side it remain the define the action of a type
substitution on a semantic environment $\eta$. It returns a new
semantic environment that interprets each substituted type according
to $\eta$.
\TFsubstToEnv

With these definitions in place, we can state the type of the logical relation.
\LogicalMCVType
The  relation {\AVSem} on values is defined by induction on the type $T$ and the parameter
$\rho$ contains the relation environment. The intention is to define a
relation on objects of type $T$ after closing $T$ with the relation
environment. Hence, we apply $\rho$'s type substitution to the type of
the syntactic value and interpret $T$ in the environment created from
the relation environment.
The value relation is mutually recursive with the expression relation
{\AESem}, which interposes evaluation.
\LogicalMCVBody
The definition itself is fairly straightforward from the literature,
except for the type adjustments using the {\Asubst} function. We
discuss those type adjustments after explaining the relations.

At the number type, values are constants equal to their semantic
interpretation. 
 At function type $T_1 \Rightarrow T_2$ we relate a lambda expression
to a semantic function $f$ in
the usual way: given arguments $w$ and $z$ related at type $T_1$, we ask that the
application of the lambda to $w$ evaluates to a syntactic value $v$ that is
related to $(f z)$ at type $T_2$.
We interpret a type variable by looking it up in the relation
environment.
At universal type $\forall l, T$ we relate a big lambda to a semantic
function $F$ as follows: given any type argument $T'$ and relation $R :
\AREL\ T'$, evaluating the type application to a syntactic value $v$,
we find that this $v$ is related at type $T$ to the
function $F$ applied to the semantics of $T'$, but in an extended
relation environment that binds the type variable to $(T', R)$.

The expression relation extends the value relation by interposing
evaluation on the syntactic side. The denotation $z$ remains the
same, which is the essence of denotational semantics. 
\LogicalMCE

The definitions of {\AVSem} and {\AESem} are terminating because their
recursive invocations strictly refer to subterms of the argument type.

The occurrence of {\Asubst} in two places indicates that the expected types do not quite
match the demanded types.
The case for type variables has to cater for the action of the
substitution $\pi_1\rho$ on the semantics. The semantics of type $T$
is parameterized over the interpretation of its free type
variables. Hence, we have to show that the semantics of the type is
preserved by this substituion.
\TFsubstVarPreservesType
The case for type application has to cater for an equality between
type substitutions that boils down to a standard lemma on composing
substitutions.
\LogicallemmaOne

The reader may wonder if these two type mismatches are an
artifact of our definition. For example, we might have chosen a
different type for the value relation:
\LogicalVariationMCVType
Alas, this choice gets rid of the {\Asubst} in the case for type
variables, but an additional {\Asubst} is needed in the case for type
application. We will not go further into this matter.
\LogicalVariationMCVBodyUniversal

We close with a usability aspect.
In the definition of {\AVSem} it is crucial that we only pattern match
against the type and enforce the structure of values by equations on
the right hand side of the definitions. This choice ensures that {\AVSem}
reduces as soon as the type is sufficiently known.

\subsection{Semantic soundness}
\label{sec:relat-open-expr}

To lift the expression relation {\AESem} to open expressions we start
with an expression of type \texttt{$e$ : Expr Δ Γ T} and want to relate it
to its denotational interpretation \AESemx{\ensuremath{e}}. As the type $T$
may also contain type variables, we first need a relational
environment $\rho$ and its semantic counterpart $\eta$ to interpret
the type variables as suitable sets.
Next, we need a closing substitution $\chi$ that maps the free
variables of $e$ to closed values while taking into account the
instantiation of the type variables. On the denotational side, we need
a corresponding semantic environment \texttt{γ : Env Δ Γ η} that maps
free variables of $e$ to their denotations. Finally, the closing
substitution and the semantic environment need to send variables to
items related by {\AVSem}. To this end, we extend {\AVSem} to
environments.

Taken together, these assumptions enable the definition of semantic soundness.
\FundamentalSemanticSoundness

Let's dissect the parts. First, the closing value substitution:
\LogicalCSub
This type is pretty much the same as the type for an expression
substitution with two differences. First, it is indexed by a closing
type substitution $\sigma^*$ and, second, it returns a closed value instead of an
expression. The latter is needed to prove the variable case of the
fundamental lemma. There is a projection function to obtain the
underlying expression substitution analogous to $\pi_1$.
\LogicalESSC

The relation {\AGSem} extends {\AVSem} to relate closing substitutions
with semantic environments. The {\AlevelEnv} function (omitted) calculates the universe level
of the resulting conjunction from the levels of the types in the
context.
\LogicalMCG
The empty environments are related in the empty context.
If the context starts with a variable binding, then the head entries of
the environments are related by {\AVSem} and their tails are
related by {\AGSem}.
The various \texttt{drop} functions pop the head entry from the
respective environments.
If the context starts with a type variable binding, then this binding
does not contribute to the relation, but we still have to skip over it
by popping the head entry of the relation environment and adjusting the
substitution and the semantic environment.
The respective \texttt{drop} and \texttt{drop-t} functions may be
found in the supplemental material.

\subsection{Fundamental theorem}
\label{sec:fundamental}

The fundamental theorem of the logical relation tells us that we can
prove semantic soundness for a well-typed expression.
\FundamentalFundamentalType

This proof is very easy for constants and for the successor.
\FundamentalFundamentalConstant
The three components of the resulting value of type {\AESem} contain
\begin{enumerate}
\item the result is a syntactic value for the number $n$,
\item evidence that this value reduces to itself, and
\item the value relation: the denotational semantics yields the same
  number $n$ with the two {\Arefl}s fixing the equality between the
  syntactic value and the semantics. 
\end{enumerate}
\FundamentalFundamentalSuccessor
Here we just lift the relation that we obtain as an induction
hypothesis for $e$ to the successor.
\FundamentalFundamentalVariable
The case for variables relies on the machinery we built up so
far. We obtain the syntactic value of the variable from the
substitution $\chi$. Then we obtain the value relation for this value
from {\AGSem} and construct the result from $w$, the proof that $w$
evaluates to itself, and the value relation. We have to rely on
{\AValueDown} for the proof because there is no way to infer the shape
of $w$ from $T$ (which might be a type variable, for instance).
We will have a closer look at some technicalities involving
{\AGLookup} in Section~\ref{sec:technical-lemmas}  

\FundamentalFundamentalLambda
The intuition of the case for lambda abstraction is
well-known. Roughly, we
have to show that for all values $w$ and $z$, which are related at
type $T_1$, the result of function application is related at type
$T_2$. To this end, we invoke the fundamental theorem at type $T_2$
with suitably extended context, closing substitution, semantic
environment, and relational environment. The latter requires some
lemmas as shown in $eq_1$ and $eq\omega_1$: if we extend an
environment by one entry and then drop that entry, the resulting
environment is extensionally equal to the initial one. The lemma
$eq\omega_1$ requires equality at $\ASeto$, so a custom version
{\Asubstlo} of the {\Asubst} function is needed: it applies two
equalities, one at a finite level, the other at level $\omega$. The
fundamental theorem gives the correct result, only its type needs to be adjusted
using a standard equation $eq_2$ about substitutions.

\FundamentalFundamentalApplication
The case for function application is proved by invoking the respective
inductive hypotheses and exploiting the definition of the value
relation for functions.


We defer the remaining cases to the supplemental material.
The case for type abstraction is similar, but slightly more involved than the case
for lambda abstraction.
The case for type application constitutes an outright annoying
excursion to ``subst hell'', where an overwhelming number of type
mismatches needs to be addressed in the proof. Section~\ref{sec:subst-hell} explains
ways of handling these problems.

\subsection{Adequacy}
\label{sec:adequacy}

The adequacy theorem constitutes the holy grail of any development
using logical relations.
Suppose we have a closed expression $e$ of number type.
If the denotational semantics of $e$ is the number $n$, then the big-step
semantics applied to $e$ terminates and yields the syntactic value for
$n$.
To state adequacy we first have to construct an empty
environment of type \texttt{Env [] {\Anull} []}.
\begin{minipage}{0.3\linewidth}
  \FundamentalEmptyEnv
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \FundamentalEmptyRelEnv
\end{minipage}
\begin{minipage}{0.3\linewidth}
  FundamentalEmptyCSub
\end{minipage}
\FundamentalAdequacyType
This theorem follows immediately from the semantic soundness that we proved with the
fundamental theorem.
\FundamentalAdequacyBody
We just invoke the fundamental theorem with empty context and empty
environments and analyze the result. The auxiliary lemma
{\ACsubClosed} proves that applying the empty substitution acts like
the identity substitution on a closed expression.
\FundamentalCsubClosed


\subsection{Technical lemmas}
\label{sec:technical-lemmas}

The variable case of the fundamental theorem relies on the function
{\AGLookup} to obtain the value relation for the variable from the
value relation for the context. 
\LRVrenMCGLookupType

Its definition starts innocently:
\LRVrenMCGLookupBody

{\dots} but the type of the inductive hypothesis \textit{ih} is
significantly different from the expected type.
The following lemma describes this discrepancy: The value relation for
the weakened type $T$ in the relation environment $\rho$ is the same
as the value relation for $T$ in the relation environment $\rho$ after
dropping the head entry. We will not delve into the technical
explanation of the required equalities on type substitutions and
semantics functions.
\LRVrenLRVwk
To add insult to the injury, this lemma cannot be proved directly, but
it rather has to be generalized to arbitrary renamings acting on the
type.
We can finally prove this renaming lemma with another excursion to
``subst hell''.
\LRVrenLRVrenEqType

The proof of the renaming lemma is the one place where we refer to the
lemma {\AFusionESubESub} for expression substitutions.

There is also a version {\ALRVsub} of the above lemma where a type substitution
(instead of a type renaming) acts on a logical relation. This
adaptation is needed to prove the case for type application of the
fundamental lemma.

\section{A Journey to Subst-Hell}
\label{sec:subst-hell}

The largest difficulty in the formalization is caused by an unfortunate
technical nuisance involving the {\Asubst}-lemma from Agda's standard library:

\SubstExamplesDef

The {\Asubst}-lemma allows to use a value of a type at a different,
but propositionally equivalent type.
This lemma becomes relevant when an equality proof cannot be matched
on, because it witnesses the equality between two non-unifiable
expressions, e.g. between two function applications: \texttt{f x $\equiv$ g y}.

It is harmless to use {\Asubst} in a proof, but if a {\Asubst} appears
in the \emph{type} of a proof, then often complications arise.
Consider for example the type \texttt{Vec} -- a list that
intrinsically tracks its length -- and its append function \verb/_++_/:
\SubstExamplesVec
\SubstExamplesAppend

Stating that \verb/_++_/ is associative requires us to use a {\Asubst}:
\SubstExamplesAssocType
The term \texttt{(xs ++ ys) ++ zs} has type \texttt{Vec A ((m + n) + p)}, whereas
the term \texttt{xs ++ (ys ++ zs)} has type \texttt{Vec A (m + (n + p))}, so a
{\Asubst} is needed to apply the associativity of addition.

\SubstExamplesAppendR

% \SubstExamplesAssoc
\SubstExamplesAssocR

% \SubstExamplesAssocHet
\SubstExamplesAssocRHet

\SubstExamplesDistSubst
\SubstExamplesSubstRemovable


% It is harmless to use {\Asubst} in proofs, but if it is used in
% regular definitions, then complications arise in subsequent
% equational lemmas about those definitions, where the {\Asubst}
% reappears.

% Old Example %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % Consider for example the definition of the substitution type:
% % \SubstExamplesESubDef

% Consider for example the definition of the identity expression-substitution:
% \SubstExamplesEidDef

% One would expect \texttt{Eid} to simply map each variable \texttt{x}
% to its corresponding variable term \texttt{\AgdaInductiveConstructor{`} x}.
% However, because the type of expression substitutions \texttt{ESub} is
% indexed by a type-substitution -- in this case \texttt{Tid} -- we need
% to produce a value of type \texttt{Expr Δ Γ (Tsub Tid T)}, while
% the variable term \texttt{\AgdaInductiveConstructor{`} x} has type \texttt{Expr Δ Γ T}.
% The two types are obviously equivalent, but only propositionally due
% to the lemma \texttt{TidT≡T : ∀ T → Tsub Tidₛ T ≡ T}, so a
% {\Asubst} is needed to adjust the type.\footnote{
%   Similar problems also appear if separate definitions for
%   expression-in-expression and type-in-expression substitutions are
%   employed instead of indexing expression-substitutions with type-substitutions.
% }

% This {\Asubst} now reappears in lemmas about \texttt{Eid}, e.g. when proving
% that \texttt{Eid} is the neutral element for expression-substitution \texttt{Esub}:
% \SubstExamplesEidNeutral

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Related Work}
\label{sec:related-work}

Arjen Rouvoet's thesis~\cite{DBLP:phd/basesearch/Rouvoet21} gives an
excellent overview of the state of the art in intrinsically typed
techniques for modeling language semantics. He pushed the limits of
this technology in a range of papers with various coauthors
\cite{DBLP:journals/pacmpl/RestPRVM22,DBLP:journals/pacmpl/RouvoetKV21,DBLP:conf/cpp/RouvoetPKV20,DBLP:journals/pacmpl/PoulsenRTKV18}. 

Giving semantics in an interpretive style is a defining feature of
denotational semantics \cite{Schmidt1986}, but it can be traced back
to Reynolds's idea of definitional interpreters \cite{Reynolds1975}.

The particular encoding of de Bruijn style variable representations
used in this work dates back to work on nested datatypes
\cite{DBLP:conf/mpc/BirdM98,DBLP:journals/jfp/BirdP99,DBLP:conf/csl/AltenkirchR99},
which subsequently lead to GADTs
\cite{cheney03:_first_class_phant_types}.

A tagless interpreter for a simply typed calculus was developed in
Cayenne \cite{augustsson99}, but for extrinsically typed syntax (i.e.,
syntax and separate typing predicatepe).

Intrinsically typed encodings are further studied by Allais and others
\cite{DBLP:conf/cpp/Allais0MM17}, who define a range of tagless
functions including denotational semantics on intrinsically typed
terms. 

We draw some inspiration from the program implemented by Benton and coworkers
\cite{DBLP:journals/jar/BentonHKM12}. Based on intrinsically typed
syntax for a simply-typed lambda applied calculus, they define a
big-step semantics and a set-theoretic denotational semantics. They
prove soundness of the former semantics with respect to the latter as
well as adequacy (using a logical relation). They also develop an
intrinsically typed expression encoding for System~F and discuss the
definitions of renaming and substitution for types and expressions.
While their expression encoding is slightly different (their
expression context does not contain type variable bindings), they run
into very similar problems with equalities on type substitutions than
our work. While they propose to lift all reasoning to heterogeneous
equality, we additionally propose a direct approach to deal with
equalities. 
The paper stops short of discussing the denotational/operational
semantics of System~F nor does it define a logical relation for it.

Chapman and coworkers \cite{DBLP:conf/mpc/ChapmanKNW19} formalized
System F$\omega$ in Agda using intrinsically typed encodings for types
and terms. Our encodings for types, terms, and substitutions are
simplified versions of their definitions, while their work is
significantly complicated by the need to normalize types. While they
prove similar results about type substitutions than we do, they do not
prove the fusion lemmas for expression substitutions (see
Section~\ref{sec:substitutions:expr}). The latter fusion lemmas are needed to
prove the fundamental theorem (see
Section~\ref{sec:technical-lemmas}), but they are not required for
their executable formalization of System~F$\omega$.

\section{Conclusion}
\label{sec:conclusion}
\label{sec:future-work}


% We are currently formalizing the small-step semantics of the language
% with the goal of proving an adequacy theorem for reduction with
% respect to the denotational semantics.

A few extensions seem within reach. It should be possible to extend
our approach to System F$\omega$ as formalized by
\citet{DBLP:conf/mpc/ChapmanKNW19}. The logical relation as such would
not be affected, but the supporting lemmas would have to be adjusted.

It would also be interesting to extend the stratified calculus by
level quantification as in Agda's universe polymorphism. However, Agda
assigns universe polymorpic functions the type $\ASeto$. In
consequence,  this extension no longer has a seamless denotational
embedding in Agda as the meaning of a term lives either in $\ASet\
\ell$  or in $\ASeto$. A suitable result type is defineable, 


%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
% \begin{acks}
% To Robert, for the bagels and explaining CMYK and color spaces.
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}


%%
%% If your work has an appendix, this is the place to put it.
% \appendix


\end{document}
\endinput
%%
%% End of file `sample-acmsmall-submission.tex'.
