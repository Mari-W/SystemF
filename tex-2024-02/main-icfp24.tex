\documentclass[acmsmall,anonymous,review,screen]{acmart}
\pdfoutput=1
\usepackage{agda}
\usepackage{stmaryrd}
\usepackage{listings}

%% There is a limit of 25 pages for a full paper or Functional Pearl
%% and 12 pages for an Experience Report; in either case, the
%% bibliography and an optional clearly marked appendix will not be
%% counted against these limits. Submissions that exceed the page
%% limits or, for other reasons, do not meet the requirements for
%% formatting, will be summarily rejected. 


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\input{unicodeletters}
\input{agdamacros}

%% listings
\lstset{
  language=haskell,
  basicstyle=\ttfamily,
  morekeywords={send,recv,close,send_on_,receive,End,Int,Chan},
  captionpos=b,
  literate=
  {-o}{${\multimap}$}1
  {ex}{$\exists$}1
  {all}{$\forall$}1
  {\\x}{$\times$}1
  %{(x)}{$\otimes$}1
  {fresh}{$\lozenge$}1
  {~~}{$\approx$}1
}


\usepackage{agda-generated}


\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Intrinsic Types, a Logical Relation, and the Scourge of the Transfer Lemma}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%% Author with single affiliation.
\author{Hannes Saffrich}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0009-0004-7014-754X}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  % \department{Department1}              %% \department is recommended
  \institution{University of Freiburg}            %% \institution is required
  %\streetaddress{Street1 Address1}
  %\city{City1}
  % \state{State1}
  % \postcode{Post-Code1}
  \country{Germany}                    %% \country is recommended
}
\email{saffrich@informatik.uni-freiburg.de}          %% \email is recommended


\author{Peter Thiemann}
% \authornote{Both authors contributed equally to this research.}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

\author{Marius Weidner}
% \authornotemark[1]
\email{weidner@cs.uni-freiburg.de}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
We explore the definition of an intrinsically typed interpreter for
stratified System F in Agda.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Agda, stratified System F, extensionality}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{sec:introduction}

Defining semantics is one of the key activities of a programming
languages researcher. We learn that there are different styles of
dynamics (small-step, big-step, denotational, just to name the most
frequently used one), each with different trade-offs. When it comes to
implementing or mechanizing semantics, there are further options to
choose from, in particular if we are also interested in statics.

One important choice is whether we want to express the statics
extrinsically or intrinsically, that is, do we want to start with
untyped syntax and then define the statics as an afterthought, or do
we integrate types with the syntax.

If we opt for intrinsically typed syntax, some properties are already paid
for by construction. For instance, a small-step semantics for intrinsically typed
syntax satisfies type preservation by construction. For another
instance, consider specifying a denotational semantics by a
compositional mapping from syntax to some semantic domain. With 
untyped syntax, the semantic domain has to lump the interpretations of
different types together and distinguish them using type tags. But with intrinsically
typed syntax the semantics can map into type-indexed semantic domains
and thus elide type tags. This observation directly translates to tagless interpreters
on intrinsically typed syntax, which elide tag checks at run time.

For concreteness, we show the well-known example of a tagless
interpreter for the simply-typed lambda calculus implemented in Agda in
Figure~\ref{fig:stlc}. We define the syntax as an inductive data type along with
a compositional mapping to the semantic domain, spanned by Agda's
natural number type and the function space. 
We define intrinsically typed syntax of expressions as an inductive datatype
parameterized over a typing environment and indexed on the return
type. For variables, we use de Bruijn indices into the typing
environment.
\begin{figure}[tp]
  \input{latex/STLC}
  \caption{Simply typed lambda calculus, denotationally}
  \label{fig:stlc}
\end{figure}

The semantics of a typing environment is a run-time environment in the
form of a heterogenous list of suitably typed values. With all that,
we can define the semantics of an expression {\AESem} as a function from
the semantics of a typing environment {\AGSem} to the semantics of the type
{\ATSem}. Clearly this definition also serves as a tagless interpreter for
the simply-typed lambda calculus, which means that type preservation
is also built into its definition. Moreover, as Agda accepts this
definition as terminating, we know that evaluation of every
simply-typed lambda term terminates; a non-trivial semantic property
of the simply-typed lambda calculus.

Agda-encodings of intrinsically-typed interpreters have been explored
quite a lot, but rarely in the context of polymorphic source
languages. One possible reason is that the archetypical polymorphic
lambda calculus, System~F, cannot be embedded in Agda because of its
impredicativity. This begs the question if we can develop a tagless
interpreter for a predicative version of System~F in Agda.

We answer this question affirmatively for Leivant's stratified version
of the polymorphic lambda calculus \cite{DBLP:journals/iandc/Leivant91}. The key idea of his
calculus is to stratify the set of polymorphic types in levels such
that universal quantification only ranges over strictly smaller
levels. This restriction literally embodies predicativity and, as we
will discover, the stratification corresponds directly to Agda's
universe stratification.


% As the construction is more involved than the one for simply-typed
% lambda calculus, we only give the key definitions and discuss some of
% the problems arising on the way to tagless interpretation. 

% \input{latex/Tagless-final}
\section{Types}
\label{sec:types}

The definition of the type language for stratified System~F is taken literally from Leivant's
paper. It is defined as an inductive type parameterized over a level
environment (that assigns levels to free type variables) and indexed
over the level of the type. 
\TFType
The unit type lives at level $0$. Type variables live at their
declared level.
The level of a function type $S \Rightarrow T$ is the maximum of the
levels of $S$ and $T$. The level of a universal quantification at
level $l$ is the maximum of $l + 1$ and the level of the body.

As for the simply-typed lambda calculus, we can define a compositional
mapping from type syntax to Agda types.
\TFTSem
Given a type at level $l$, this function returns an Agda type in
$\ASet~l$. To do so it needs a domain environment to interpret type
variables. This environment gets extended in the last clause that maps
universal quantification to a dependent function that takes an element
of $\ASet~l$ and pushes it on the environment.

The type of the domain environment is interesting because its range type is
unusual.
\TFTEnv
As a value in the environment (the interpretation of a type, colloquially speaking) can live
in a $\ASet~l$, for any finite level $l$, we 
cannot assign the type any finite level. Hence, the type {\ADEnv} lives in
the limit type $\ASeto$, which we use in this definition. 

\section{Expressions}
\label{sec:expressions}

Inspired by the encoding of System $F\omega$ by Chapman and coworkers
\cite{DBLP:conf/mpc/ChapmanKNW19}, we define a 
unified environment for type variables and term variables. Type
environments grow to the left.
\TFTVEnv
Membership of a term variable in a type environment is defined by the
inn relation.
\TFinn
In the last alternative, we skip over a type binding. Hence, the type
$T$ we find under the binding must be weakened to account for the
extra type variables. Weakening is a special case of renaming, which
is implemented as advocated by Benton and coworkers \cite{DBLP:journals/jar/BentonHKM12}.

The type of expressions is now given as follows.
\TFExpr
Variables, lambda abstractions, and application are encoded just like
for the simply-typed lambda calculus.
Type abstraction takes a level $l$ and a body where the new type
variable is bound to $l$. 
Type application takes an expression with universal quantification at
level $l$ and a type $T'$ of level $l$. It constructs an expression
where type $T'$ has been substituted in the body $T$ of the
quantified type. Substitution is defined as in PLFA
\cite{DBLP:journals/jar/BentonHKM12,DBLP:journals/scp/KokkeSW20}. 

\section{Semantics}
\label{sec:semantics}

\subsection{Denotational}
\label{sec:denotational}



It remains to define a compositional function from the expression
syntax to the semantic domain that we already prepared in
Section~\ref{sec:types}. We start with value environments.
\TFVEnv
Value environments are represented as functions---we could have done
that in the simply-typed interpreter, too. They are indexed by a
domain environment to be able to calculate the correct return type.

The definition of the interpretation function follows.
\TFExprSem
The cases for term variables, lambda abstraction, and application are
similar to the  simply-typed lambda calculus.

The first issue arises in the case for type abstraction. We interpret
a type abstraction at level $l$ as a function with argument type
$\ASet~l$. This argument has to be pushed onto the domain environment
$\eta$ and we have to account at the value level for the additional
type variable in the type environment. The following function
adapts the types.
\TFExtendTskip
The lemma we need in the rewrite clause proves that interpreting a
weakened type in an extended domain environment gives the same result
as interpreting the type in the orginal domain environment.
The statement of this lemma is more general as it applies to arbitrary
renamings:
\TFRenPreservesSemanticsType
The argument $ren*$ roughly states that $\eta_1$ and $\eta_2$ are domain
environments related by renaming $\rho$ by precomposition  $\eta_1 \equiv \eta_2 \circ \rho$.
The proof of the lemma is by induction on $T$ with an interesting
subgoal in the case for universal quantification:
%\TFProblematicGoal
We can show that the ranges of the function are equal
with the inductive hypothesis. But the usual extensionality principle does
not let us expose this equation. However, it can be used to prove a
dependent extensionality principle (from the standard library), which enables us to complete the proof.
\TFDependentExt

The final case for type application opens two different cans of
worms. First, the type of the right hand side does not match the
expected type. Essentially, we have to prove that the composition of
the meaning function for types commutes with substitution. Here
$T[T']$ substitutes $T'$ for the outermost variable of $T$.
\TFSingleSubstPreserves
Second, some steps in the proof involve equalities over entities of
$\ASeto$. These cannot be handled with the standard definition of
propositional equality which works parametrically for entities of
$\ASet~l$, for any $l$, but not for $\ASeto$. While it is easy to
define these equalities, it is somewhat tedious to re-establish
standard lemmas for transforming equality proofs
like cong, subst, and trans to deal with $\ASeto$.

\subsection{Big Step Operational}
\label{sec:big-step-operational}

A standard big-step operational semantics serves as the second
reference point for the logical relation. We discuss it here because
it contains a design choice that is crucial for proving the
fundamental theorem in Section~\ref{sec:fundamental}.

We start by defining the
standard notions of closed expressions {\ACExpr} and values {\AValue}, the latter being
pairs of a closed expression and evidence {\AisValue} that it is a syntactic value.
\BigStepCExpr
\BigStepisValue
\BigStepValue
The evaluation judgment relates closed expressions to closed values.
Its inference rules define a standard call-by-value evaluation.
We treat the ``big lambda'' as a syntactic value for
simplicity.\footnote{This choice works out for the
  side-effect-free language that we consider here. If the language had
  effects, we would enforce the well-known value restriction by
  requiring the body of the big lambda to be a syntactic value.}
\BigStepSemantics

The reader may wonder why the relation does not simply relate two closed
expressions. While this alternative works almost all the way, we
failed to prove the (expression) variable case of the fundamental theorem with
it. The problem is that the variable case does not constrain the type
of the variable's value. In particular, the type of a variable can be
a type variable, so that the type is unknown at compile time.

However, with our present setup we can use the following lemma to show
that a syntac value evaluates to itself.
\BigStepValueReduceSelf

\section{Logical Relation}
\label{sec:logical-relation}

The definition of the logical relation largely follows the development
of Ahmed's thesis/lecture notes \cite{AhmedLR}. 

We define a binary logical relation for stratified System F. It
relates syntactic values of type $T$ to semantic value of the same
type. This relation {\AREL} is indexed by the stratification level.
\LogicalREL
A relation environment {\ARelEnv} abstracts over the current instantiation of the
type variables. It maps a type variable to a
type paired with its relational interpretation. 
\LogicalRelEnv
Clearly, the first ``half'' of a relation environment is a type
substitution and we use the function SUBSTFROMRE to obtain this
substitution.

With these definitions in place, we can state the type of the logical relation.
\LogicalMCVType
The relation is defined by induction on the type $T$ and the parameter
$\rho$ contains the relation environment. The intention is to define a
relation on objects of type $T$ after closing $T$ with the relation
environment. Hence, we apply $\rho$'s type substitution to the type of
the syntactic value and interpret $T$ in the environment created from
the relation environment.
\LogicalMCVBody
The definition itself is fairly straigthforward from the literature.
We interpret a type variable by looking it up in the relation
environment.
At function type $T_1 \Rightarrow T_2$ we relate a lambda expression
to a semantic function $f$ in
the usual way: given arguments $w$ and $z$ related at type $T_1$, we ask that the
application of the lambda to $w$ evaluates to a syntactic value $v$ that is
relates to $(f z)$ at type $T_2$.
At universal type $\forall l, T$ we relate a big lambda to a semantic
function $F$ as follows: given any type argument $T'$ and relation $R :
\AREL\ T'$, evaluating the type application to a syntactic value $v$,
we find that this $v$ is related at type $T$, but in an extended
relation environment that binds the type variable to $(T', R)$, to the
function $F$ applied to the semantics of $T'$.
At the number type, values are constants equal to their semantic
interpretation. 

The expression relation extends the value relation by interposing
evaluation on the syntactic side. The denotation $z$ remains the
same. 
\LogicalMCE

In the definition of {\AV} it is crucial that we only pattern match
against the type and enforce the structure of values by equations on
the right hand side of the definitions. This choice ensures that {\AV}
reduces as soon as the type is sufficiently known.

The occurrence of {\Asubst} in two places indicates that the expected types do not quite
match the demanded types. The reader may wonder if this mismatch is an
artifact of our definition. For example, we might have chosen a
different type for {\AV}:
\LogicalVariationMCVType
Alas, this choice gets rid of the {\Asubst} in the case for type
variables, but a new {\Asubst} is needed in the case for type
application.

\section{Related Work}
\label{sec:related-work}

Arjen Rouvoet's thesis~\cite{DBLP:phd/basesearch/Rouvoet21} gives an
excellent overview of the state of the art in intrinsically typed
techniques for modeling language semantics. He pushed the limits of
this technology in a range of papers with various coauthors
\cite{DBLP:journals/pacmpl/RestPRVM22,DBLP:journals/pacmpl/RouvoetKV21,DBLP:conf/cpp/RouvoetPKV20,DBLP:journals/pacmpl/PoulsenRTKV18}. 

Giving semantics in an interpretive style is a defining feature of
denotational semantics \cite{Schmidt1986}, but it can be traced back
to Reynolds's idea of definitional interpreters \cite{Reynolds1975}.

The particular encoding of de Bruijn style variable representations
used in this work dates back to work on nested datatypes
\cite{DBLP:conf/mpc/BirdM98,DBLP:journals/jfp/BirdP99,DBLP:conf/csl/AltenkirchR99},
which subsequently lead to GADTs
\cite{cheney03:_first_class_phant_types}.

A tagless interpreter for a simply typed calculus was developed in
Cayenne \cite{augustsson99}, but for extrinsically typed syntax (i.e.,
syntax and separate typing predicatepe).

Intrinsically typed encodings are further studied by Allais and others
\cite{DBLP:conf/cpp/Allais0MM17}, who define a range of tagless
functions including denotational semantics on intrinsically typed
terms. 

We draw some inspiration from the program implemented by Benton and coworkers
\cite{DBLP:journals/jar/BentonHKM12}. Based on intrinsically typed
syntax for a simply-typed lambda applied calculus, they define a
big-step semantics and a set-theoretic denotational semantics. They
prove soundness of the former semantics with respect to the latter as
well as adequacy (using a logical relation). They also develop an
expression encoding for System~F, but the paper stops short of
discussing its semantics. 

\section{Future Work}
\label{sec:future-work}

We are currently formalizing the small-step semantics of the language
with the goal of proving an adequacy theorem for reduction with
respect to the denotational semantics.

It would also be interesting to extend the stratified calculus by
level quantification as in Agda's universe polymorphism.


%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
% \begin{acks}
% To Robert, for the bagels and explaining CMYK and color spaces.
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}


%%
%% If your work has an appendix, this is the place to put it.
% \appendix


\end{document}
\endinput
%%
%% End of file `sample-acmsmall-submission.tex'.
